<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
		<link rel="icon" type="image/x-icon" href="./assets/img/JavaScript-logo.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JavaScript Training</title>
	<link rel="stylesheet" href="./assets/css/global.css">
  </head>
  <body>
		<div class="reveal">
			<div class="menubar" id="menubar">
				<div class="dropdown">
					<input id="checkbox_toggle" type="checkbox">
					<label for="checkbox_toggle" data-i18n="chooselanguage">Choose language</label>
					<div class="langchooser">
						<label>
								<input type="radio" name="menulangradios" value="en" checked><span>English</span>
						</label>
						<label>
								<input type="radio" name="menulangradios" value="fr"><span>Français</span>
						</label>
					</div>
				</div>
			</div>
			<div class="slides">
				<section id="intro">
					<a href="./"><img src="./assets/img/JavaScript-logo.png" alt="logo" class="logo"></a>
					<h1 data-i18n="title">JavaScript Training</h1>
					<p>
						<a href="https://github.com/worldline/JS-Training" target="_blank">
							https://github.com/worldline/JS-Training
						</a>
					</p>
        </section>
				<section class="small-list">
					<ul>
						<li>
							This course is for developers who already have a beginner to an intermediate level in JavaScript and who 
							wish to deepen their knowledge of this language to better understand more ambitious JavaScript projects.
						</li>
						<li>
							It is classified as advanced, which means that we will focus more on the technical points of the language 
							and on the study of some advanced programming patterns.
						</li>
						<li>
							The training focuses on the language and is agnostic of any framework or environment, meaning that you 
							will be able to apply these lessons to both front-end (Angular, Vue.js, Ember...) and back-end (Node.js).
						</li>
						<li>
							It is the ideal opportunity to review and consolidate the basics for all those who have learned 
							JavaScript "on the job", or to prepare or complement a training on a modern web framework.
						</li>
					</ul>
				</section>
				<section class="agenda">
					<h1>Agenda</h1>
					<div class="flex-slide">
						<div style="flex-basis: 100%;">
							<h3>Introduction</h3>
							<ul>
								<li>ECMAScript, TC39 and versions of JavaScript</li>
							</ul>
	
							<h3>A reintroduction to JavaScript</h3>
							<ul>
								<li>Primitives and Objects</li>
								<li>Property descriptors</li>
								<li>Scopes and Closures</li>
								<li>Functions and contexts</li>
								<li>Implicit casts</li>
							</ul>
						</div>

						<div style="flex-basis: 100%;">
							<h3>Modern JS: ES2015+</h3>
							<ul>
								<li>Arrow functions</li>
								<li>Default parameters</li>
								<li>Spread / Rest</li>
								<li>Destructuring</li>
								<li>Template literals</li>
								<li>Map and Sets</li>
								<li>Modules</li>
							</ul>
	
							<h3>Managing asynchrony</h3>
							<ul>
								<li>Asynchronous, what is it?</li>
								<li>Callbacks and Publisher/Subscriber model</li>
								<li>Promises</li>
								<li>async / await</li>
								<li>Observables</li>
							</ul>
						</div>

						<div style="flex-basis: 100%;">
							<h3>Object oriented</h3>
							<ul>
								<li>Prototypes and delegation</li>
								<li>class / super / extends</li>
								<li>Composition of objects</li>
								<li>Symbols, iterables and generators</li>
								<li>Proxies</li>
							</ul>
	
							<h3>Functionally oriented</h3>
							<ul>
								<li>Recursivity</li>
								<li>Chainable APIs</li>
								<li>Composition of functions</li>
								<li>Curryfication</li>
							</ul>

							<h3>Transpilers</h3>
							<ul>
								<li>Babel</li>
								<li>TypeScript</li>
								<li>JSX</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<section>
						<h2>Cheat Sheets</h2>
						<p>It can be useful</p>
					</section>
					<section>
						<h3>String Methods</h3>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim data-line-numbers>
							"str".charAt(1) === "str"[1] === "t"
							"a".concat("b") === "a" + "b" === "ab"
							"str".startsWith("s") === true
							"str".endsWith("r") === true
							"str".includes("st") === true
							"toto".indexOf("t") === 0
							"toto".lastIndexOf("t") === 2
							"str".search(/t/) === 1
							"str1".match(/r(\d)/) => ["r1", "1"]
							"Hi Bob".replace(/Hi (\w+)/, "Hello $1") => "Hello Bob"
							"string".slice(0,3) === "str"
							"1,2,3".split(",") => ["1","2","3"]
							"STR".toLowerCase() === "str"
							"str".toUpperCase() === "STR"
							"  str  ".trim() == "str"
						</code></pre>
					</section>
					<section>
						<h3>Array Methods</h3>
						<pre style="font-size: 50%"><code class="javascript hljs" data-trim data-line-numbers>
							[1,2].concat([3,4], 5, 6) // [1,2,3,4,5,6]
							[1,2,3].fill(4) // [4,4,4]
							[1,2,3].includes(2) // true
							[1,2,3].indexOf(2) // 1
							[1,2,3].join("-") // "1-2-3"
							[1,2,3,4].slice(1,3) // [2,3]
							
							[1,2,3,4].every((value, index, arr) => n > 2) // false
							[1,2,3,4].some((value, index, arr) => n > 2) // true
							[1,2,3,4].find((value, index, arr) => n > 2) // 3
							[1,2,3,4].findIndex((value, index, arr) => n > 2) // 2
							[1,2,3,4].filter((value, index, arr) => n > 2) // [3,4]
							[1,2,3,4].forEach((value, index, arr) => { ... })
							[1,2,3,4].map((val, index, arr) => val * 2) // [2,4,6,8]
							[1,2,3,4].reduce((accu, n) => accu + n, "test") // "test1234"
							[1,2,3,4].reduceRight((accu, n) => accu + n, "test") // "test4321"
							
							// /!\ Mutative methods, original array is modified!
							let arr = [3,2,1]
							arr.push(4,5) // returns new array.length (5), a = [3,2,1,4,5]
							arr.pop() // returns last item (5), a = [3,2,1,4]
							arr.unshift(6,5) // returns new array.length (6) ; a = [6,5,3,1,2,4]
							arr.shift() // returns first item (6) ; a = [5,3,1,2,4]
							arr.splice(1,2,7,8) // at index 1, remove 2 items, insert (7,8) ; [5,7,8,2,4]
							arr.sort((a,b) => a-b) // [2,4,5,7,8]
							arr.reverse() // [8,7,5,4,2]
						</code></pre>
					</section>
					<section>
						<h3>Map</h3>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim data-line-numbers>
							let map = new Map([ ['key1', 'val1'], ['key2', 'val2'] ])
							let key = {}, value = {} // any type
							
							map.set(key, value)
							map.get(key) === value
							map.has(key) === true
							map.delete(key);
							map.size === 2
							
							let keys = [...map.keys()]
							let values = [...map.values()]
							let fusionMap = new Map([...map1, ...map2])
							
							for(let [key, val] of map){ }
							map.forEach((val, key, map) => {})
						</code></pre>
					</section>
					<section>
						<h3>Set</h3>
						<pre><code class="javascript hljs" data-trim data-line-numbers>
							let mySet = new Set([ 1,2,3,4 ])
								▸ Set(4) {1, 2, 3, 4}

							mySet.add("any type")
							map.has(3) === true
							map.delete(3);
							map.size === 4;
							map.clear(); // remove all
							 
							for(let item of mySet){}
							mySet.forEach(item => {})
							let items = [...mySet];
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>Introduction</h2>
						<p>
							Who manages JavaScript? How is the language evolving? <br />
							ECMAScript, TC39 and JavaScript versions
						</p>
					</section>
					<section>
						<h3 class="flex-center">ECMAScript <img height="50px" src="assets/img/ecma.jpg"></h3>
						<ul>
							<li>
								<b>ECMA International</b> is an organisation that creates standards for technologies
							</li>
							<li>
								<b>ECMAScript</b> is the name of the specification referenced ECMA-262 and describing a general purpose scripting language
							</li>
							<li>
								<b>TC39</b> is the name of the technical committee that decides on developments in the ECMAScript specification. 
								It is composed of delegates from <b>major companies</b> (including all browser providers) and <b>invited experts.</b>
							</li>
							<li>
								<b>JavaScript</b> is a versatile scripting language and the most popular implementation of ECMAScript<br>
								<em>(another popular implementation: ActionScript)</em>
							</li>
						</ul>
					</section>
					<section style="text-align: left;">
						<h3>JavaScript Evolutions</h3>
						<p>
							TC39 is considering proposals for ECMAScript developments. Each proposal goes through 5 stages:
						</p>
						<ul>
							<li>0:
								<b>Strawman -</b> suggestion of a need, call for ideas
							</li>
							<li>1:
								<b>Proposal -</b> draft solution, first polyfills/demos
							</li>
							<li>2:
								<b>Draft -</b> precisely describes the syntax/API
							</li>
							<li>3:
								<b>Candidate -</b> signed by the whole committee, call for implementations
							</li>
							<li>4:
								<b>Finished -</b> ready to be included in the next version of ES
							</li>
						</ul>
						<div style="text-align: center;">
							<p>TC39 proposals and meetings are public: <a href="https://github.com/tc39">github.com/tc39</a></p>
							<aside class="note warning">
								Any proposal before stage 4 can be dropped completely. <br />
								However, from stage 3 onwards, the level of confidence is quite high.	
							</aside>
						</div>
					</section>
					<section>
						<h3>Versions of ECMAScript</h3>
						<img src="./assets/img/ecmascript-versions.png" height="150px">
						<p>
							A long delay between initial draft and release implies many browser-specific implementations.
						</p>
						<p>
							TC39 has decided to move to an annual release schedule from ES6, renamed <b>ES2015</b>
						</p>
						<p>
							Since 2015, a new version of the ECMAScript specification is released every year: ES2016, ES2017...
						</p>
					</section>
					<section>
						<h3>ECMAScript browser implementation</h3>
						<p>
							As a result of the new annual rhythm:<br />
							<small>an excellent, comprehensive and consistent support across all modern browsers</small>
						</p>
						<div class="flex-center">
							<p>So-called "<span class="green">evergreen</span>" browsers</p>
							<img height="450px" src="./assets/img/evergreen.png">
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>A reintroduction to JS</h2>
						<p>Exercises 1 to 6</p>
					</section>
					<section style="text-align: left;">
						<h3>Exercises</h3>
						<p>
							Slides and exercises available on Github:
							<a href="https://github.com/worldline/JS-Training">https://github.com/worldline/JS-Training</a>
						</p>
						<p>
							Do the exercises from your browser at this address:
							<a href="https://codesandbox.io/s/github/SDCOAdvocates/JS-Training">https://codesandbox.io/s/github/SDCOAdvocates/JS-Training</a>
						</p>
						<img src="./assets/img/Image1.png">
						<p>
							Fork to create your personal version of the working repo. 
							You can publish it on your personal Github account if you have one.
						</p>
						<div class="flex-center">
							<img height="142px" src="./assets/img/Image2.png">
							<img height="142px" src="./assets/img/Image3.png">
							<img height="142px" src="./assets/img/Image4.png">
						</div>
						<p>For each exercise, correct the source to validate the associated test</p>
					</section>
					<section>
						<span class="ref">Exercise 1</span>
						<h3>Types and Primitives</h3>
						<p>JavaScript defines 7 data types:</p>
						<img height="250px" src="./assets/img/Image5.png">
						<p>The <b class="monospace">typeof</b> operator returns the type of an object, but be careful:</p>
						<pre><code class="javascript hljs" data-trim>
							typeof null === "object" // bug of the 1st version of ES
							typeof function(){} === "function"
						</code></pre>
					</section>
					<section>
						<h3>null or undefined</h3>
						<ul>
							<li><b class="monospace">undefined</b> : the variable is declared but not assigned</li>
							<li><b class="monospace">null</b> : the variable has been assigned to the null reference</li>
						</ul>
						<p>
							<b class="monospace">null</b> represents the intentional absence of value and often comes from an assignment by the developer
						</p>
						<aside class="note warning">
							Don't assign variables to undefined. Use the delete operator instead:<br>
							<img height="70px" src="./assets/img/Image6.png">
						</aside>
					</section>
					<section style="text-align: left;">
						<h3>Objects</h3>
						<p>Functions, <b class="monospace">arrays</b> and derivatives are all of type <b class="monospace">object</b>. Unlike primitives, objects:</p>
						<ul>
							<li>are compared by reference</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							"test" === "test"
							▸ true
								
							{ item: "test" } === { item: "test" }
							▸ true
						</code></pre>
						<ul>
							<li>have a list of properties that are key-value pairs: key (String, Symbol) ⇔ value (any)</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							"item" in { item: "test" }
							▸ true
							
							Symbol.iterator in [1,2,3]
							▸ true
						</code></pre>
					</section>
					<section>
						<span class="ref">Exercise 2</span>
						<h3 class="flex-center">Objects: properties listing</h3>
						<pre style="font-size: 90%"><code class="javascript hljs" data-trim>
							let obj = { a: 1, b: 2 }

							"a" in obj
							▸ true

							for(let key in obj) console.log(key, obj[key])
							▸ a 1
							▸ b 2

							Object.keys(obj)
								▸ ["a", "b"]
							Object.values(obj)
								▸ [1, 2]
							Object.entries(obj)
								▸ [ ["a", 1], ["b", 2] ]
						</code></pre>
					</section>
					<section>
						<span class="ref">Exercise 3</span>
						<h3>Objects: properties assignment</h3>
						<pre><code class="javascript hljs" data-trim>
							let obj = { key: "value" }
							obj.a = 1;
							obj["b"] = 2;
							Object.assign(obj, { c: 3, d: 4}, {d: 5});
								▸ {key: "value", a: 1, b: 2, c: 3, d: 5}

							Object.fromEntries([ ['a', 1], ['b', 1]]);
								▸ {a: 1, b: 2}
						</code></pre>
						<aside  class="note info">
							<b class="monospace">Object.assign</b> is very useful for assigning default values 
							or assigning a set of properties in a single statement
						</aside>
					</section>
					<section style="text-align: left;">
						<h3>Property descriptors</h3>
						<p>Each property contains in addition to its value, a list of intrinsic parameters called <b>descriptors</b>:</p>
						<ul>
							<li><b class="monospace">value:</b> <em>the value of the property</em></li>
							<li><b class="monospace">enumerable: true</b> <em>if the property is returned by Object.keys or for..in</em></li>
							<li><b class="monospace">writable: true</b> <em>if the value of the property can be modified</em></li>
							<li><b class="monospace">configurable: true</b>: <em>if the descriptor can be modified</em></li>
							<li><b class="monospace">get</b>: <em>optional function to use as getter</em></li>
							<li><b class="monospace">set</b>: <em>optional function to use as mutator (setter)</em></li>
						</ul>
						<p>A default assignment is enumerable, modifiable and configurable, without specific accessors or mutators</p>
					</section>
					<section>
						<span class="ref">Exercise 4</span>
						<h3>Define the descriptors</h3>
						<p>The method <b class="monospace">Object.defineProperty()</b> allows you to assign a property by specifying its descriptors</p>
						<div class="flex-center">
							<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
								const obj = {}

								Object.defineProperty(obj, 'a', {
									value: 1,
									enumerable: true,
									writable: false
								});

								Object.defineProperty(obj, {
									b: { enumerable: true, value: 2 },
									c: { get: function(){ return 3 } },
								});
									
								▸ {a: 1, b: 2}			
							</code></pre>
							<img height="325px" src="./assets/img/Image7.png">
						</div>
					</section>
					<section>
						<h3>Getters / Setters</h3>
						<p>Literal declaration for get / set descriptors:</p>
						<pre><code class="javascript hljs" data-trim data-line-numbers>
							const user = {
								name: "Smith",
								first: "John",

								get fullName(){
									return this.first + " " + this.name.toUpperCase()
								},

								set fullName(value){
									this.first = value.split(" ")[0];
									this.name = value.split(" ")[1];
								}
							}
						</code></pre>
					</section>
					<section>
						<h3>Own and delegated properties</h3>
						<p>
							The properties assigned to an object are called the <b>own properties</b> of the object. 
							But there are other types of properties, the <b>delegated properties</b>.
						</p>
						<img height="150" src="./assets/img/Image8.png">
						<p>These delegated properties are in fact the properties of the object's prototype (see Object Oriented section)</p>
						<pre><code class="javascript hljs" data-trim>
							obj.toString === Object.prototype.toString
							▸ true
						</code></pre>
					</section>
					<section>
						<h3>Scopes</h3>
						<p><b>Scope</b> = perimeter from which variables can be accessed.</p>
						<p>At the highest level, we are in the global scope, accessible everywhere.</p>
						<img height="300" src="./assets/img/Image9.png">
						<p>
							Accessible from global scope<span class="green">(1)</span> : <span class="monospace">foo</span><br />
							Accessible from function foo scope <span class="red">(2)</span> : <span class="monospace">foo, a, b, bar</span><br />
							Accessible from function bar scope <span class="blue">(3)</span> : <span class="monospace">foo, a, b, bar, c</span><br />
						</p>
					</section>
					<section>
						<h3>Block scopes</h3>
						<p>In addition to function scopes, some instructions create so-called <b>block scopes</b></p>
						<p>These are known as <b>block instructions:</b></p>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>
								if(){ ... }
								for(){ ... }
								while(){ ... }
							</code></pre>
							<img height="150" src="./assets/img/Image10.png">
						</div>
						<p>
							A block scope can also be declared with <span class="monospace">{ ... }</span> <br />
							<em>(not to be confused with a literal object declaration)</em>
						</p>
					</section>
					<section>
						<h3>var, let or const?</h3>
						<ul>
							<li><b class="monospace">let</b> and <b class="monospace">const</b> appeared with ES2015</li>
							<li><b class="monospace">var</b> is no longer in use since</li>
						</ul>
						<div class="flex-slide">
							<img height="250" src="./assets/img/Image11.png">
							<table>
								<thead><tr><th></th><th>Scope</th><th>Re-assignable</th></tr></thead>
								<tbody>
									<tr><td class="monospace">var</td><td>function</td><td>yes</td></tr>
									<tr><td class="monospace">let</td><td>block</td><td>yes</td></tr>
									<tr><td class="monospace">const</td><td>block</td><td>no</td></tr>
								</tbody>
							</table>
						</div>
						<aside class="note info"><u>Recommended:</u> Use <b class="monospace">const</b>, or <b class="monospace">let</b> if you need to reassign</aside>
					</section>
					<section>
						<h3>Closures</h3>
						<p>Scope of a function = local scope + parent scope = local variables + free variables</p>
						<p>
							A function using <b>free variables</b> (defined in a parent scope) creates what is called a <b>closure</b>. 
							A closure must remember its parent scope in order to execute correctly.
						</p>
						<div class="flex-center">
							<aside class="note">
								<b class="monospace">add5</b> <em>retains its parent scope with x=5</em><br><br>
								<em>This link prevents the garbage collector from dereferencing the local variable x at the end of the add</em>
								<br><br>
								<b class="monospace">add5</b> <em>creates a closure</em>
							</aside>
							<pre><code class="javascript hljs" data-trim>
								function add(x) {
									return function(y) {
										return x + y;
									}
								}

								var add5 = add(5);
								add5(8)
								▸ 13
							</code></pre>
						</div>
						<aside class="note warning">
							Unintentional closures are the most common source of <b>memory leaks</b> problems in web applications.
						</aside>
					</section>
					<section>
						<h3>Using closures</h3>
						<p>"Private" variables</p>
						<pre><code lass="javascript hljs" data-trim>
							function getCounter() {
								let value = 0;
								return {
									getValue(){ return value },
									increment() { value += 1}
								}
							}
						</code></pre>
						<p>Outside the scope of the <b class="monospace">getCounter</b> function, the value variable will never be accessible.</p>
						<p>Only the <b class="monospace">getValue</b> and <b class="monospace">increment</b> closures allow access</p>
					</section>
					<section>
						<span class="ref">Exercise 5</span>
						<h3>Using closures</h3>
						<pre><code class="javascript hljs" data-trim>
							for (var i = 1; i&lt;=3; i++) {
								setTimeOut( function timer(){
									console.log( i );
								}, i*1000 );
							}

							▸ 4
							▸ 4
							▸ 4
						</code></pre>
						<aside class="note">
							Note that closures retain a reference to the parent scope,<br> 
							and therefore access free variables by <b>reference</b>, not by value. <br>
							<br>
							The value of the free variables can therefore vary with respect to the time of instantiation of the function.
						</aside>
					</section>
					<section>
						<h3>Functions and execution context</h3>
						<p>
							Functions have a "hidden argument" called <b>context</b> and assigned to the keyword <b class="monospace">this</b>. When the function 
							is called as a property (<b>method</b>) of an object, that object is assigned as execution context:
						</p>
						<pre><code class="javascript hljs" data-trim>
							const obj = {
								whoisthis(){ return this }
							}

							obj.whoisthis() === obj
							▸ true
						</code></pre>
						<p>
							When a function is called by direct reference, it has no context, which means the <code>this</code> variable will be looked up in parent scope.</p>
						<p>At the <b>root scope</b>, the context is defined as the <b>global context</b> (<span class="monospace">Window</span> on browser)</p>
						<img height="80" src="./assets/img/Image12.png">
					</section>
					<section>
						<h3>Functions and execution context</h3>
						<p>
							The execution context can be changed with the methods 
							<span class="monospace">call</span>, 
							<span class="monospace">apply</span> and <span class="monospace">bind</span>
						</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							function greet(a, b) {
								return `Hi I'm ${this.name} ! ${a} + ${b} equals ${a+b} !`
							}

							let alice = { name: "Alice" },
									bob = { name: "Bob" };

							greet.call(alice, 1, 2)
							▸ "Hi I'm Alice ! 1 + 2 equals 3 !"

							greet.apply(bob, [2, 3])
							▸ "Hi I'm Bob ! 2 + 3 equals 5 !"

							let greetBob = greet.bind(bob, 1, 5)
							greetBob()
							▸ "Hi I'm Bob ! 1 + 5 equals 6 !"
						</code></pre>
					</section>
					<section>
						<h3>Primitives and object equivalents</h3>
						<p>
							<span class="monospace">String()</span>, <span class="monospace">Number()</span>, 
							<span class="monospace">Boolean()</span> are the object equivalent constructors of the corresponding 
							primitives, also called <b>primitive wrappers</b>
						</p>
						<p>The switch between object and primitive is automatic:</p>
						<div class="flex-center">
							<div style="flex-basis: 100%;">
								<p class="center">Primitive -> Object</p>
								<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
									let str = "abc";

									str.length; // 3
									str.toUpperCase(); // "ABC"
								</code></pre>
							</div>
							<div style="flex-basis: 100%;">
								<p class="center">Object -> Primitive</p>
								<pre style="font-size: 60%"><code class="javascript hljs" data-trim>
									let Str = new String( "abc" ),
											str = Str.valueOf() // ou "" + Str
									let N = new Number( 42 ),
											n = N.valueOf() // +N

									console.log(Str, typeof Str) // "abc", "object"
									console.log(str, typeof str) // "abc", "string"
									console.log(N, typeof N) // 42, "object"
									console.log(n, typeof n) // 42, "number"
								</code></pre>
							</div>
						</div>
						<aside class="note">Generally, primitive wrappers constructors are not called explicitly</aside>
					</section>
					<section>
						<h3>Type conversions (cast)</h3>
						<p>There are 3 types of implicit conversions in JS:</p>
						<table class="slide-array" style="width: 80%">
							<thead><tr><th></th><th>Explicit cast</th><th>Implicit cast</th><th>Cast operators</th></tr></thead>
							<tbody>
								<tr>
									<td>ToString</td>
									<td><pre><code class="javascript hljs" data-trim>
										String(42)
										▸ "42"
									</code></pre></td>
									<td><pre><code class="javascript hljs" data-trim>
										12 + "34"
										▸ "1234"
									</code></pre></td>
									<td><pre><code data-trim>'' +</code></pre></td>
								</tr>
								<tr>
									<td>ToNumber</td>
									<td><pre><code class="javascript hljs" data-trim>
										Number("42")
										▸ 42
									</code></pre></td>
									<td><pre><code class="javascript hljs" data-trim>
										+"42"
										▸ 42
									</code></pre></td>
									<td>
										<pre><code class="javascript hljs" data-trim>- + * / %</code></pre>
										<pre><code class="javascript hljs" data-trim>> &lt; &lt;= >=</code></pre>
										<pre><code class="javascript hljs" data-trim>| & ^ ~</code></pre>
									</td>
								</tr>
								<tr>
									<td>ToBoolean</td>
									<td><pre><code class="javascript hljs" data-trim>
										Boolean(1)
										▸ true
									</code></pre></td>
									<td><pre><code class="javascript hljs" data-trim>
										!!1
										▸ true
									</code></pre></td>
									<td>
										<pre><code class="javascript hljs" data-trim>|| && !</code></pre>
									</td>
								</tr>
							</tbody>
						</table>
						<aside class="note info">Recommended: cast explicitly and as soon as possible</aside>
					</section>
					<section>
						<h3>== or === ?</h3>
						<p>
							== weak equality (with conversion) <br />
							=== strict equality (without conversion)
						</p>
						<img height="250" src="./assets/img/Image13.png">
						<aside class="note info">
							The rules for conversion with weak equality are complex. <br /> 
							It's recommended to use strict equality, which is more predictable.
						</aside>
					</section>
					<section class="quizz">
						<span class="ref">Quiz</span>
						<h3>Implicit casts</h3>
						<div class="flex-slide">
							<div style="flex-basis: 100%;">
								<p><pre class="fragment fade"><code>"0"-0</code></pre><pre class="fragment fade"><code>▸ 0</code></pre></p>
								<p><pre class="fragment fade"><code>"0"+0</code></pre><pre class="fragment fade"><code>▸ "00"</code></pre></p>
								<p><pre class="fragment fade"><code>+"1"+2</code></pre><pre class="fragment fade"><code>▸ 3</code></pre></p>
								<p><pre class="fragment fade"><code>+1+"2"</code></pre><pre class="fragment fade"><code>▸ "12"</code></pre></p>
							</div>

							<div style="flex-basis: 100%;">
								<p><pre class="fragment fade"><code>!"0"</code></pre><pre class="fragment fade"><code>▸ false</code></pre></p>
								<p><pre class="fragment fade"><code>!+"0"</code></pre><pre class="fragment fade"><code>▸ true</code></pre></p>
								<p><pre class="fragment fade"><code>+!"0"</code></pre><pre class="fragment fade"><code>▸ 0</code></pre></p>
								<p><pre class="fragment fade"><code>+"test"</code></pre><pre class="fragment fade"><code>▸ NaN</code></pre></p>
							</div>

							<div style="flex-basis: 100%;">
								<p><pre class="fragment fade"><code>+[1]</code></pre><pre class="fragment fade"><code>▸ 1</code></pre></p>
								<p><pre class="fragment fade"><code>+[1,2]</code></pre><pre class="fragment fade"><code>▸ NaN</code></pre></p>
								<p><pre class="fragment fade"><code>![]</code></pre><pre class="fragment fade"><code>▸ false</code></pre></p>
								<p><pre class="fragment fade"><code>!+[]"</code></pre><pre class="fragment fade"><code>▸ true</code></pre></p>
							</div>
						</div>
					</section>
					<section>
						<h3>Logical operators</h3>
						<p>Operands are converted to Booleans to evaluate the operator, but the original values are returned</p>
						<pre><code class="javascript hljs" data-trim>
							let a = 42,
							b = "abc",
							c = null;
							
							a || b; 	// 42
							a && b;		// "abc"
							
							c || b;		// "abc"
							c && b;		// null
						</code></pre>
						<aside class="monospace note info">
							a || b ⇔ a ? a : b <br>
							a && b ⇔ a ? b : a
						</aside>
						<p>
							If the implicit Boolean cast of a value is <span class="monospace">true</span>, 
							the value is said to be <em>truthy</em>, otherwise <em>falsey</em>
						</p>
					</section>
					<section>
						<span class="ref">Quiz</span>
						<h3>Logical operators</h3>
						<p>
							The operators <span class="monospace">||</span> and <span class="monospace">&&</span>, 
							the ternary conditions <span class="monospace">?:</span> and <br>
							<span class="monospace">if else</span> statements execute only one operand here:
						</p>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>if(0) log('A'); else log('B');</code></pre>
							<p class="fragment fade">B</p>
						</div>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>undefined ? log('C') : log('D');</code></pre>
							<p class="fragment fade">D</p>
						</div>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>true && log('E'); false && log('F');</code></pre>
							<p class="fragment fade">E</p>
						</div>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>true log('G'); false || log('H');</code></pre>
							<p class="fragment fade">H</p>
						</div>
						<p>
							The <span class="monospace">&&</span> operator has priority over <span class="monospace">||</span> 
							which has priority over <span class="monospace">?:</span>
						</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Upgrade to modern JS: ES2015+</h1>
						<p>Exercises 7 to 11</p>
					</section>
					<section>
						<h3>Syntactic sugar: key and value</h3>
						<pre><code class="javascript hljs" data-trim>
							let foo = "foo", bar = "bar"

							const obj = { foo, bar } // equivalent to { foo: foo, bar: bar }

							obj
							▸ {foo: "foo", bar: "bar"}
						</code></pre>
					</section>
					<section>
						<h3>Syntactic sugar: calculated keys</h3>
						<pre><code class="javascript hljs" data-trim>
							let foo = "foo", bar = "bar"

							const obj = {
								[foo]: [bar],
								[foo+bar]: foo+bar
							} 
							
							/* equivalent to
							obj[foo] = [bar]
							obj[foo+bar] = foo + bar
							*/
						</code></pre>
						<pre><code class="javascript hljs" data-trim>
							obj
							▾ {foo: Array(1), foobar: "foobar"}
								▸ foo: ["bar"]
									foobar: "foobar"
						</code></pre>
					</section>
					<section class="left">
						<span class="ref">Exercise 7</span>
						<h3>Arrow functions</h3>
						<pre><code class="javascript hljs" data-trim>
							const f1 = () => {},
										f2 = x => x*2,
										f3 = (a,b,c) => { return a+b+c }
						</code></pre>
						<p>Functions declared with this shortened syntax have specific features:</p>
						<ul>
							<li>No execution context <br>
							<span class="grey">(the value of <span class="monospace">this</span> is looked up in the parent scope)</span></li>
							<li>Cannot be invoked as builders</li>
						</ul>
						<p>Short and effective, they encourage a functional, no-frills style <em>(no closure)</em>.</p>
						<aside class="note info">Recommended for all non-method functions</aside>
					</section>
					<section>
						<h3>Default parameters</h3>
						<p>
							Assigns a default value if argument === <span class="monospace">undefined</span>
						</p>
						<pre><code class="javascript hljs" data-trim>
							function f(a, b=1, c=2) { return a + b + c }

							f(1, 2, 3)
							▸ 6
							f(1, null, null)
							▸ 1
							f(1, undefined, undefined)
							▸ 4
							f(1)
							▸ 4
						</code></pre>
						<p>Also works with the arrow functions:</p>
						<pre><code class="javascript hljs" data-trim>const doSomething = (params = {}) => {}</code></pre>
					</section>
					<section>
						<h3>Operators Spread / Rest</h3>
						<p>Spread: converts an iterable object into an argument list</p>
						<pre><code class="javascript hljs" data-trim>
							const sum = (a,b,c) => a+b+c;

							sum(...[1,2,3])
							▸ 6

							sum(1, ...[2,3])
							▸ 6

							[1, ...[2,3], 4]
							▸ (4) [1,2,3,4]
						</code></pre>

						<pre><code class="javascript hljs" data-trim>const cloneArray = arr => [...arr]</code></pre>
					</section>
					<section>
						<h3>Operators Spread / Rest</h3>
						<p>Rest : converts a list of arguments into an Array</p>
						<pre><code class="javascript hljs" data-trim>
							const sum = (...args) => args.reduce((a,b) => a+b, 0);

							sum(1,2,3,4)
							▸ 10

							function addToList(list, ...args) { // rest
								list.push(...args) // spread
							}
						</code></pre>
					</section>
					<section class="left">
						<span class="ref">Exercise 8</span>
						<h3>Operators Spread / Rest</h3>
						<p>Object properties (ES2018)</p>
						<p>Only works with enumerable properties</p>
						<ul>
							<li>Rest properties:</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
							x; // 1
							y; // 2
							z; // { a: 3, b: 4 }
						</code></pre>
						<ul>
							<li>Spread properties:</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							let n = { x, y, ...z };
							n; // { x: 1, y: 2, a: 3, b: 4} 
						</code></pre>
					</section>
					<section>
						<h3>Destructuring</h3>
						<p>Assigns variables according to an object / Array structure</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							const userData = { first: "Joe", name: "Dalton", age: 27 };
							
							const { first, age, name: userName } = userData;
							// first = "Joe", age = 27, userName = "Dalton"

							const myObject = {
								foo: {
									bar: 42
								}
							}
							const { foo: { bar: magicNumber } } == myObject
							// magicNumber = 42

							const [first, second, fourth] = [1,2,3,4];
							// first = 1, second = 2, fourth = 4
						</code></pre>
					</section>
					<section class="left">
						<span class="ref">Exercise 9</span>
						<h3>Destructuring</h3>
						<p>Also works with function parameters:</p>
						<pre><code class="javascript hljs" data-trim>
							function doSomething({ config, options: { verbose } }){
								if(verbose) console.log("blabla");
								doSomethingElse(config);
							}

							doSomething({
								config: { ... },
								options: { verbose: true }
							})
						</code></pre>
					</section>
					<section>
						<h3>Default parameters</h3>
						<ul>
							<li>Can be expressions using other arguments or variables in the scope.</li>
							<li>If the default value is an expression, it will only be executed if necessary</li>
						</ul>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							function doSomething(data, config = retrieveDefaultConfig(data)) {
								
							}

							const required = name => throw new Error(`Missing required paramter ${name}`)

							const findUsersByRole = ({
								role = required('role'),
								maxResults = 100
							}) => { }
						</code></pre>
					</section>
					<section class="left">
						<h3>Object set in argument pattern</h3>
						<ul>
							<li>Object set with destructuring and default values:</li>
						</ul>
						<pre><code class="javascript hljs" data-trim>
							const searchProducts = ({
								minPrice = 0,
								maxPrice = 1000,
								inStock = true
							}) => {
								(...)
								return { results, size, lowestPrice }
							}

							const { results, size } = searchProducts({ maxPrice: 500 });
						</code></pre>

						<p>Receiving and returning a single object is very useful:</p>
						<ul>
							<li>no need to remember the order of the arguments</li>
							<li>each parameter can be optional</li>
							<li>we limit the quantity of variables to be passed from one point to another</li>
							<li>allows you to return several variables</li>
						</ul>
					</section>
					<section class="left">
						<h3>Template strings</h3>
						<p>New form of String literal declaration in ES6, using the backtick ` ` character (AltGr+7)</p>
						<p>Allows:</p>
						<div class="flex-center">
							<ul>
								<li>interpolation of variables and expressions</li>
								<li>line breaks</li>
							</ul>
							<img height="100" src="./assets/img/Image15.png">
						</div>
						<aside class="note info">Recommended: use template strings for all non-trivial strings</aside>
					</section>
					<section>
						<span class="ref">Exercise 10</span>
						<h3>Tagged Template strings</h3>
						<p>If a function reference precedes a template string, that function is invoked with the static and dynamic parts of the string:</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							function insertInUpperCase(string, ...vars) {
								console.log({ strings, vars });

								return strings.reduce(
									(out, str, i) => `${out}${str}={vars[i] || "").toUpperCase()}`
								)
							}
						</code></pre>
						<img height="150" src="./assets/img/Image16.png">
						<img height="150" src="./assets/img/Image17.png">
					</section>
					<section class="left">
						<span class="ref">Exercise 11</span>
						<h3>Map & Set</h3>
						<ul>
							<li>Map: collection of keys/values like objects, but the keys can be of any type</li>
							<li>Set: collection of values without keys, guarantee of uniqueness</li>
						</ul>
						<div class="flex-center">
							<pre><code class="javascript hljs" data-trim>
								s = new Set([1,2,3,2,4])
								▸ Set(4) {1,2,3,4}

								s.add(5);
								s.delete(3);
								▸ Set(4) {1,2,4,5}

								s.has(4)
								▸ true
							</code></pre>
							<pre><code class="javascript hljs" data-trim>
								m = new Map([
									["key", "value"], [ s, s.size ]
								])
								▸ Map(2) { "key" => "value", Set(4) => 4}
								
								m.get(s)
								▸ 4
								
								m.set([1,2,3], [4,5,6])
								m.delete("key")
								
								▸ Map(2) {Set(4) => 4, Array(3) => Array(3)}
							</code></pre>
						</div>
					</section>
					<section class="left">
						<h3>Modules (a.k.a. ES Modules or ESM in short)</h3>
						<p>The long awaited standard solution for managing modular code (divided into several separate files)</p>
						<p><b><u>Replaces and supersedes:</u></b></p>
						<ul>
							<li>
								CommonJS (used in particular by Node)
								<pre><code class="javascript hljs" data-trim>const $ = require('jquery')</code></pre>
							</li>
							<li>
								Asynchronous Module Definition (AMD)
								<pre><code class="javascript hljs" data-trim>define(['jquery', 'underscore'], function($,_){ 

});</code></pre>
							</li>
						
							<li>
								Universal Module Definition (UMD)<br>
								<em>Pattern combining CommonJS, AMD and using global variables to be sure to be understood by all module systems</em>
							</li>
							<li>the use of global variables and the <span class="monospace">&lt;script></span> to be ordered</li>
						</ul>
					</section>
					<section>
						<h3>Modules</h3>
						<div class="flex-center">
							<div>
								<p>Two keywords: <span class="monospace">import</span> and <span class="monospace">export</span></p>
								<p>A distinction is made between named imports and default imports</p>
								<pre><code class="javascript hljs" data-trim>
									import MonModule from './mon-module.js'
									import { a, b as two } from 'module'
									import React, { Component } from 'react'

									export const a = 42
									export function b(){ ... }
									export default { Component, View }
								</code></pre>
							</div>
							<img height="350" src="./assets/img/Image14.png">
						</div>
					</section>
					<section class="left">
						<h3>Modules</h3>
						<p>Modules have a different execution context to traditional scripts:</p>
						<ul>
							<li>
								strict mode used by default <span class="monospace">("use strict";)</span>
								<ul>
									<li>explicit exceptions on certain silent errors</li>
									<li>new keywords are reserved as variable names</li>
									<li>forbids variables not explicitly declared</li>
								</ul>
							</li>
							<li>no global context (<span class="monospace">this === undefined</span> in the global scope)</li>
						</ul>
						<p>The code must therefore be parsed differently if it is a module:</p>
						<ul>
							<li>On browser: <pre><code>&lt;script type="module" src="index.js"&gt;&lt;/script&gt;</code></pre></li>
							<li>
								On Node.js: use <span class="monospace">.mjs</span> extension instead of <span class="monospace">.js</span>, 
								or have <span class="monospace">{ type: "module" }</span> in package.json
							</li>
						</ul>
					</section>
					<section>
						<h3>Modules</h3>
						<img height="350" src="./assets/img/Image21.png" alt="">
						<p>
							<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">
								https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/
							</a>
						</p>
					</section>
					<section>
						<h3>Modules: dynamic import </h3>
						<p>
							When <span class="monospace">import</span> is called as a function, the module is imported asynchronously. <br>
							This is very useful for downloading code on demand and optimising the loading time of your applications.
						</p>
						<img height="250" src="./assets/img/Image18.png">
					</section>
					<section>
						<h3>Modules: what about support?</h3>
						<p>
							Average support (~93%) in 2021: Chrome 61, Edge 16, Firefox 60
							But developers use them widely in their codebases with bundlers like Webpack, Parcel, Rollup, esbuild...
						</p>
						<img height="200" src="./assets/img/Image19.png">
						<p>Bundlers preempt the browser's work by producing optimised JS bundles from a set of modules.</p>
					</section>
					<section>
						<h3>Modules: script nomodule</h3>
						<p>
							Browsers that do not support modules can load an alternative script 
							with the attribute <span class="monospace">nomodule</span>
						</p>
						<img height="125" src="./assets/img/Image20.png">
						<p>
							Bundlers can take advantage of this attribute to produce two bundles, a "modern" and a "legacy" 
							bundle with more transpiled code. <br>
							The "modern" bundle will be lighter and more efficient.
						</p>
					</section>
					<section class="left">
						<h3>Modules : recommandations</h3>
						<p>Always use ESM modules and avoid other existing module systems</p>
						<p>Using a bundler with the "Modern build" option</p>
						<div class="flex-center">
							<ul>
								<li>Parcel: for simplicity and speed of implementation</li>
								<li>Webpack: for complex web applications</li>
								<li>Rollup: for JS libraries</li>
							</ul>
							<img height="100" src="./assets/img/Image22.png" alt="">
						</div>
					</section>
				</section>
				<section>
					<section>
						<h2>Deal with Asynchrony</h2>
						<p>Exercises 12 to 14</p>
					</section>

					<section class="left">
						<h3>What is Asynchronism ?</h3>
						<p>JavaScript is executed in an <b>mono-thread environment</b> (the engine only runs one instruction at a time).</p>
						<p>Some instructions may take some time (I/O, network requests…) and must not block the execution of the rest of the program.</p>
						<p>So we make them <b>asynchronous</b>: they declare a function call to be carried out later, after a defined or undefined period.</p>
						<p>These future function calls are stored in stacks, and the engine decides when to pop the calls.</p>

						<pre><code class="javascript hljs" data-trim>
							setTimeout(function calledAfter5Seconds(){
								console.log("bye !")
							}, 5 * 1000)

							console.log("hello !")
						</code></pre>
					</section>

					<section class="left">
						<h3>Callbacks</h3>
						<p>The most common interface for asynchronous instructions is the <b>callback function</b>.</p>
						<p>It consists of passing as parameter of an asynchronous function another function (the callback) which will be called later.</p>
						<pre><code class="javascript hljs" data-trim>
							let callback = function(result){ console.log(result) }

							setTimeout(callback, 1000);

							element.addEventListener('click', callback);
						</code></pre>
					</section>

					<section class="left">
						<span class="ref">Exercise 14</span>
						<h3>Publisher/Subscriber</h3>
						<p>This asynchronous communication pattern is based on a principle of subscription to a flow of events.</p>
						<p><code>element.addEventListener</code> is an example of pub/sub.</p>
						<br />
						<p>A pub/sub keeps in memory a list of callbacks (the <b>subscribers</b>).</p>
						<p>It is composed of at least two functions: <b>subscription</b> and <b>emission</b></p>
						<p>Example of a pub/sub API:</p>
						<pre><code class="javascript hljs" data-trim>
							const publisher = new PubSub();

							publisher.on("alert", function onAlert(eventData){
								console.log(eventData)
							})

							publisher.emit("alert", "something happened")
						</code></pre>
					</section>

					<section class="left">
						<h3>Drawbacks of callbacks</h3>
						<p>Callbacks show their limits when a series of asynchronous operations must be chained (executed one after the other).</p>
						<div class="center"><img height="250" src="./assets/img/callback-hell.jpg" alt="The callback hell"></div>
						<p>An exception raised by a callback cannot be catched directly from the parent scope, which is why error handling is often handled with a second argument of the callback function or a second callback function dedicated to error handling.</p>
					</section>

					<section>
						<h3>Promises</h3>
						<ul>
						<li>Promises are objects used to facilitate the coordination of asynchronous operations.</li>
						<li>A Promise represents the promise of a return value in the future. The delay is not necessarily predictable, this value can be available almost immediately or never arrive.</li>
						<li>A Promise is always in one of these 3 states:
						<ul>
							<li><b>pending</b>: initial state, waiting</li>
							<li><b>fulfilled</b>: the promise has been resolved, the operation was successful</li>
							<li><b>rejected</b>: the promise was rejected due to an error</li>
						</ul>
						</li>
						</ul>
					</section>

					<section>
						<h3>Callbacks vs Promises</h3>
						<div class="flex-center" style="align-items: stretch; gap: 1em">
							<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
doSomething(function(result){

	doAnotherThing(result, function(newResult){

		doFinalThing(newResult, function(finalResult){
			console.log("Final result: ", finalResult)
		}, failureCallback)

	}, failureCallback)

}, failureCallback)</code></pre>
							<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
doSomething()
.then(function(result){
	return doAnotherThing(result)
})
.then(function(newResult){
	return doFinalThing(newResult)
})
.then(function(finalResult){
	console.log("Final result", finalResult)
})
.catch(failureCallback)
							</code></pre>
						</div>
					</section>

					<section>
						<span class="ref">Exercise 13</span>
						<h3>Creation of a promise</h3>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
						// creating a promise from a callback-based API
						const promise = new Promise((resolve, reject) => {
							const callback = (err, result) => err ? reject(err) : resolve(result)
							doSomethingAsynchronous(callback)
						})

						promise.then(result => {
							console.log(`Promise resolved with ${result}`)
						})
						promise.catch(error => {
							console.log(`Promise rejected with ${error}`)
						})
						promise.finally(() => { // ES2018
							console.log(`Called after either resolve or reject of the promise`)
						})
						</code></pre>
					</section>

					<section>
						<h3>Other methods of creation of Promises</h3>
						<ul>
							<li><code>Promise.resolve(val)</code></li>
							<li><code>Promise.reject(err)</code>
							<p>create a promise immediately resolved/rejected with some value</p></li>
							<br/>
							<li><code>Promise.all([ promise1, promise2, promise3 ])</code>
								<p>create a promise resolved when all the promises passed as arguments are resolved</p>
							</li>
							<li>
								<code>Promise.race([ promise1, promise2, promise3 ])</code>
								<p>create a promise resolved when one of the promises passed as arguments is resolved</p>
							</li>
						</ul>
						<div class="center"><img height="200" src="./assets/img/promise-all-race.jpg" alt="Comparison between Promise.race and Promise.all"></div>
					</section>

					<section>
						<span class="ref">Quiz</span>
						<h3>Chaining and parallelism</h3>
						<pre><code class="javascript hljs" data-trim>
							const wait = promisify(setTimeout)

							Promise.race([
								fetch('/api/notifs').then(res => res.json()),
								wait(10000)
							]).then(([notifs]) => {
								if(notifs){ /* do something */ }
							})
						</code></pre>
						<pre class="fragment fade"><code class="javascript hljs" data-trim>
							Promise.all([
								wait(1000),
								Promise.resolve(data),
								wait(2000)
							])
						</code></pre>
						<pre class="fragment fade"><code class="javascript hljs" data-trim>
							Promise.race([
								cache ? Promise.resolve(cache) : Promise.race([]),
								fetch('/api/data').then(res => res.json())
							])
						</code></pre>

					</section>

					<section>
						<h3>Exception management</h3>
						<pre><code class="javascript hljs" data-trim>
f1()
.then(f2)
.catch(error => {
	// handle the exceptions from f1 or f2
})
.then(f3)
.catch(error => {
	// handle the exceptions coming exclusively from f3
})
							</code></pre>

							<p><code>then()</code> and <code>catch()</code> can be chained in any order. It allows intermediate error handling in a promise chain.</p>

							<aside class="note info">
								<u>Recommended:</u> handle the exceptions at the lowest level possible, but always add a <code>catch()</code> at the highest level to handle uncatched exceptions.
							</aside>
					</section>

					<section>
						<h3>async / await (ES2017)</h3>
						<p>Functions prefixed with the <code>async</code> operator can contain instructions prefixed with <code>await</code>.</p>
						<p><code>await</code> pauses the function execution waiting for the following promise to be resolved.</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
async function myFunction() {
	try {
		const result = await myPromise;
		// my Promise is resolved and the the resolved value is assigned to result
	} catch(err) {
		// myPromise is rejected with error "err"
	}

	// this line is reached only after resolve/reject of myPromise
	return 42
}</code></pre>
					</section>
				

					<section>
						<h3>async / await: pros and cons</h3>
						<p>
							<img src="./assets/img/thumb-up.png" alt="" style="float: left; clear: both; margin: 0 1em 0 0"/>
							Combines the advantage of asynchronism with the convenience of writing and reading synchronous code
						</p>
						<p>
							<img src="./assets/img/thumb-up.png" alt="" style="float: left; clear: both; margin: 0 1em 0 0"/>
							Allows to unify the management of synchronous errors (exceptions) with the cases of rejection of promises
						</p>
						<p>
							<img src="./assets/img/thumb-down.png" alt="" style="float: left; clear: both; margin: 0 1em 0 0"/>
							Does not encourage the developer to parallelize asynchronous operations, which can slow down the application
						</p>
						<aside class="note info">
							Remember this winning combo: <code>await Promise.all([ ...promises ])</code>
						</aside>
					</section>

					<section>
						<h3>Observable</h3>
						<p>A pattern halfway between Promise and Pub/Sub:
							<ul><li>Promise that can be resolved in several stages</li>
							<li>Event emitter with a completion concept</li>
						</ul></p>
						<div class="center">
							<img src="assets/img/observable-en.png" alt="Timeline of an observable" />
						</div>
						<p>Not yet standardized but easily implementable by yourself like Pub/Sub.</p>
						<p>This is one of the foundations of ReactiveX and reactive programming.</p>
					</section>

					<section>
						<span class="ref">Exercise 14</span>
						<h3>Observable: example of API</h3>
						<pre style="font-size: 65%"><code class="javascript hljs" data-trim>
const keyboardObservable = new Observable( ({ emit, complete }) => {
	const onKey = event => {
		if(event.key === "Enter") {
			complete();
			document.removeEventListener("keyup", onKey)
		}
		else emit(event.key)
	}

	document.addEventListener("keyup", onKey)
});

const keys = [];
const keyboardObserver = keyboardObservable.subscribe({
	onValue: key => {
		if (key === "Escape") keyboardObserver.unsubscribe();
		else keys.push(key)
	},
	onComplete: () => alert(keys.join(""))
});
						</code></pre>
					</section>

					<section class="left">
						<h3>Tasks, microtasks and event loop</h3>
						<p>The <b>event loop</b> is the mechanism that periodically pops the asynchronous calls.</p>
						<p>Between each iteration of the loop, the browser re-renders the page and processes user events (click, scroll, etc.)</p>
						<p>Modern JS engines store asynchronous calls in two stacks:<ul>
							<li><b>tasks</b>, unstacked at the end of each event loop (examples: <code>setTimeout</code>, <code>setInterval</code>, <code>fetch</code>)</li>
							<li><b>microtasks</b>, unstacked at the end of each task (examples: <code>promise.then</code>, <code>process.nextTick</code>)</li>
						</ul></p>
						<img src="assets/img/event-loop.jpg" alt="Schema of the event loop" />
					</section>

					<section class="left">
						<h3>Work with the event loop</h3>
						<p>Sometimes, you need to wait for the event loop:
						<ul>
							<li>to wait for the DOM to be updated before the next instruction</li>
							<li>to not block the thread when doing a heavy calculation</li>
						</ul>
						</p>
						<p>You then need to create a new task for your callback:
							<ul>
								<li><code>setTimeout(callback, delai)</code>
									with zero delay to minimize waiting time
								</li>
								<li>
									<code>requestAnimationFrame(callback)</code>
									let the browser optimize when a callback is called to get a fluid animation (~ 60 frames per second)
								</li>
								<li>
									<code>requestIdleCallback(callback)</code>
									let the browser optimize when to call the callback when the CPU is not heavily loaded <i>(non standard)</i>
								</li>
							</ul>
						</p>
					</section>

					<section>
						<span class="ref">Quiz</span>
						<h3>Work with the event loop</h3>
						<pre><code class="javascript hljs" data-trim>
setTimeout(() => console.log(1), 0)
Promise.resolve().then(() => console.log(2))
requestAnimationFrame(() => console.log(3))
requestIdleCallback(() => console.log(4))
console.log(5)
						</code></pre>

						<p>In what order are the logs displayed ?</p>
						<p class="center" style="font-weight: bold; font-size: 200%;">
						<span class="fragment fade">5 - </span>
						<span class="fragment fade">2 - </span>
						<span class="fragment fade has-brace-bottom">1 - 4 - 3
							<span class="brace"></span>
							<span class="brace-description">variable depending on the CPU activity, but it's the most likely order</span>
						</span>
						</p>
						
					</section>
				</section>

				<section>
					<section>
						<h2>Object-oriented Programming</h2>
						<p>Exercises 15 to 19</p>
					</section>

					<section class="left">
						<h3>General principles of Object Oriented Programming</h3>
						<ul>
							<li>Represent a problem with elements that can be associated with material objects or concepts</li>
							<li>Bring more proximity between code logic and business logic</li>
							<li>Manipulate objects that contain their own internal state and their own logic</li>
						</ul>
						<br />
						<p><span style="font-style: italic; text-decoration: underline;">Objectives:</span>
						<ul>
							<li>have a more intuitive, self-describing code</li>
							<li>facilitate work in parallel</li>
							<li>facilitate the transition from specification to code</li>
						</ul></p>
					</section>

					<section class="left">
						<h3>Objects and Prototypes</h3>
						<ul>
							<li>Any object has an internal private property called the <b>prototype</b></li>
							<li>Any object can be the prototype of one or many other objects</li>
							<li>You can retrieve the prototype of an object with:<br/>
							<code>Object.getPrototypeOf(obj)</code></li>
							<li>You can reassign dynamically the prototype of an object with:<br/>
							<code>Object.setPrototypeOf(obj, newProto)</code></li>
						</ul>
						<div class="note warning" style="display: block; margin-left: auto; margin-right: 0; width: 500px">
							Do not reassign the prototype in performance-critical parts of your application because it is tricky to optimize for classical JavaScript engines
						</div>
					</section>

					<section class="left">
						<h3>Why "prototype" ?</h3>
						<ul>
							<li>In industry, a <b>prototype</b> is a <b>real physical object</b>, on which mass-produced objects will be based.</li>
							<li>On the same analogy, a <b>class</b> would be more like a <b>plan or diagram to follow</b>, of a more abstract nature and which cannot be manipulated like an object.</li>
							<li>A prototype is taken as an example to create the produced objects, while a produced object can be taken as an example for the implementation of a class.</li>
						</ul>
						<p>The choice of this term serves to illustrate these differences.</p>
					</section>

					<section class="left">
						<h3>Delegation to prototype</h3>
						<p>If for <code><span class="blue">object</span>.<span class="green">prop</span></code>, the property <span class="green">prop</span> is not found in <span class="blue">object</span>, then it
						is searched for in the <b>prototype</b> of <span class="blue">object</span>, then in the <b>prototype</b> of the <b>prototype</b> of <span class="blue">object</span>, and so on...</p>
						<p>This is called <b>prototype delegation</b>, and objects have a <b>prototype chain</b>.</p>
						<p>The "root" prototype is <code>Object.prototype</code>. Its own prototype is <code>null</code>.</p>

						<pre><code class="javascript hljs" data-trim>
							Object.getPrototypeOf([1,2,3]) === Array.prototype
							▸ true
							Object.getPrototypeOf(Array.prototype) === Object.prototype
							▸ true
							Object.getPrototypeOf(Object.prototype)
							▸ null
						</code></pre>
					</section>

					<section class="left">
						<span class="ref">Exercise 15</span>
						<h3>Methods related to the prototype</h3>

						<div class="has-brace-right" style="margin-right: 300px">
							<pre><code class="javascript hljs" data-trim>
								Object.getPrototypeOf(obj)
								Object.setPrototypeOf(obj, newProto)

								let obj = Object.create(proto)

								Object.getOwnPropertyNames(obj)
								Object.getOwnPropertySymbols(obj)
								Object.getOwnPropertyDescriptors(obj)
							</code></pre>
							<div class="brace"></div>
							<div class="brace-description">Methods of the <code>Object</code> constructor</div>
						</div>

						<div class="has-brace-right" style="margin-right: 300px">
							<pre class="has-brace-right"><code class="javascript hljs" data-trim>
								obj.hasOwnProperty("prop")
								obj.isPrototypeOf(anotherObj)
							</code></pre>
							<div class="brace"></div>
							<div class="brace-description">Methods of the prototype <code>Object.prototype</code></div>
						</div>
					</section>

					<section>
						<h3>Beware of misuse of language !</h3>
						<div class="center" style="font-size: 200%; font-weight: bold">classes ≠ prototypes</div>
						<p>There are no classes in JavaScript, but the word is misused to refer to a prototype and its associated constructor.</p>
						<p>Unlike classes, there is no difference in nature between a prototype and an object. A prototype can therefore be manipulated like any other object: assigned by reference, passed as a parameter, exported as a module...</p>
						<img src="assets/img/kinds-of-oop.jpg" height="300" alt="Two kinds of OOP: an analogy with a classroom">
					</section>

					<section>
						<h3>Beware of misuse of language !</h3>
						<div class="center" style="font-size: 200%; font-weight: bold">inheritance ≠ delegation</div>
						<p class="left">An object does not inherit the properties of its prototype, but it <b>delegates</b> them to it: these are not its own properties</p>
						<pre><code class="javascript hljs" data-trim>
							const bob = Object.create({ name: "Anonymous" })
							bob.name = "Bob";

							console.log(bob.name)
							▸ "Bob"

							delete bob.name;
							console.log(bob.name)
							▸ "Anonymous"
						</code></pre>
						<div class="left">
						<p>In the context of OOP with prototypes, delegating can mean:</p>
							<ul>
								<li>retrieve default values</li>
								<li>get a generic implementation of a method</li>
								<li>implement basic behaviors (toString, cast to primitive, etc.)</li>
							</ul>
						</div>
					</section>
					
					<section class="left">
						<h3 class="center">Beware of misuse of language !</h3>
						<div class="center" style="font-size: 200%; font-weight: bold">interface, override, instance...</div>
						<p>Most of the class-based OOP vocabulary needs to be avoided:</p>
						<ul>
							<li>The prototype is neither an <i>interface</i> nor a <i>contract</i> to fulfill for the object, but an API base on which to rely.</li>
							<li>We do not <i>override</i> properties, but we delegate those that are missing</li>
							<li>The word "instance" makes sense for an instance of a class because it can mean "example". With prototypes, the roles are reversed since it is the prototype that fits better the role of example.</li>
						</ul>
						<div class="note">
							Despite these differences in definition, this vocabulary is still often used (including within the language itself) in order to remain familiar to those accustomed to Java and class-based OOP.<br/>
							It is quite the same historical aberration that brought us the name <i>"Java"</i>Script.
						</div>
					</section>

					<section>
						<h3>Constructors and operator <code class="blue">new</code></h3>
						<p>In JavaScript, a function can be called <i>as a constructor</i> with the operator <code class="blue">new</code></p>
						<pre><code class="javascript hljs" data-trim>
							function Constructor(){
								// init an object
							}

							Constructor() // called as regular function
							new Constructor() // called as constructor
						</code></pre>
						<div class="note info">It's very unlikely you intend to use a function both as a constructor and as a regular function. By convention, those who are intended as constructors have their name starting with an Uppercase letter.</div>
						<div class="note">Arrow functions cannot be invoked as constructors</div>
					</section>

					<section class="left">
						<h3>Prototypes and constructors</h3>
						<p>When <code>new Constructor()</code> is invoked, a new object is created with <code>Constructor.prototype</code> as prototype.</p>
						<p>This is equivalent to call <code>Object.create(Constructor.prototype)</code></p>
						<p >The same principle applies on all native constructors in the language:</p>
						<pre><code class="javascript hljs" data-trim>
							let today = new Date();
							today.getMonth === Date.prototype.getMonth

							let obj = {} // or new Object()
							obj.toString === Object.prototype.toString

							let array = [1,2,3] // or new Array(1,2,3)
							array.concat === Array.prototype.concat
						</code></pre>

						<p>The <code class="blue">instanceof</code> operators determines if an object has been created by the following constructor:</p>
						<pre style="font-size: 80%"><code class="javascript hljs" data-trim>
							x instanceof C ⇔ Object.getPrototypeOf(x) === C.prototype
							[] instanceof Array ⇔ Object.getPrototypeOf([]) === Array.prototype
						</code></pre>
					</section>

					<section>
						<h3>Constructors and context</h3>
						<p>The <code class="blue">new</code> operator changes the way a function is invoked in several ways:</p>
						<pre><code class="javascript hljs" data-trim>
							function hello(){
								console.log(`this === ${this}`)
							}

							let result1 = hello() // this === [object Window]
							let result2 = new hello() // this === [object Object]
						</code></pre>
						<p>The created object is used as execution context of the constructor (<code class="green">this</code>)</p>
						<div class="note">
							<code>new Constructor(…args)</code> <br/>
							≈<br/>
							<code>Constructor.call(Object.create(Constructor.prototype), ...args)</code>
						</div>
						<p>This object is also returned by default by the function, when there is no <code>return</code> instruction.</p>
						<pre><code class="javascript hljs" data-trim>
							console.log(typeof result1) // undefined
							console.log(typeof result2) // object
						</code></pre>
						
						
					</section>

					<section class="left">
						<span class="ref">Exercise 16</span>
						<h3>Constructor.prototype</h3>
						<p>Every constructor function has a <code>prototype</code> property that is an object with a <code>constructor</code> property referring to the constructor function.</p>
						<p>That's how you can retrieve the constructor from a constructed object.</p>
						<img src="assets/img/constructor-prototype.jpg" style="float:left; width: 300px; margin-right: 1em" alt="Diagram presenting Constructor and protototype property recursion" />
						<pre><code class="javascript hljs" data-trim>
							function Car() { }

							Car.prototype;
							▸ { constructor: f }

							Car.prototype.constructor === Car
							▸ true
						</code></pre>
						<p>In the prototype, we can declare other properties that will be <b>delegated</b> by the objects created with this constructor:</p>
						<pre><code class="javascript hljs" data-trim>
							Car.prototype.nbWheels = 4;
							const twingo = new Car();
							twingo.nbWheels
							▸ 4
						</code></pre>
					</section>

					<section>
						<h3>Constructor.prototype</h3>
						<div class="note warning" style="width: 500px">Not to be confused: <pre><code class="javascript hljs">Constructor.prototype</code>  ≠  <code class="javascript hljs">Object.getPrototypeOf(Constructor)</code></pre></div>
						<pre class="fragment fade"><code class="javascript hljs js" data-trim>
							function Car(){} ⇔ const Car = new Function()
						</code></pre>
						<pre class="fragment fade"><code class="javascript hljs" data-trim>
							Object.getPrototypeOf(Car) === Function.prototype
						</code></pre>
					</section>

					<section>
						<h3>Constructors flaws</h3>
						<p>Constructors are a commonly used pattern in JS, but they have several flaws:</p>
						<ul>
							<li class="fragment">The prototype constructors are not automatically invoked, you have to do it manually.</li>
							<li class="fragment">The prototype constructor may not have the same signature, which breaks the <a target="_blank" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">principle of substitution</a>.</li>
							<li class="fragment">A <code>constructor</code> property is assigned to created objects, which can break existing code if you use this property for other effects, for example: <code>car.constructor = "Toyota"</code></li>
							<li class="fragment"><code>this</code> keyword does not work the same depending on whether the function is called with operator <code>new</code> or not</li>
							<li class="fragment">It is not possible to declare several constructors</li>
							<li class="fragment">They are confusing for beginners with prototypes</li>
						</ul>
					</section>

					<section>
						<h3>The <code>class</code> operator (ES2015)</h3>
						<p>Syntaxic sugar for declaring objects with constructors</p>
						<div style="position: relative; display: flex;">
							<pre style="font-size: 60%; width: 50%;"><code class="javascript hljs js" data-trim>
class Person {
	constructor(firstname, lastname) {
		this.firstname = firstname
		this.lastname = lastname
	}

	sayMyName(){
		return `${this.firstname} ${this.lastname}`
	}
}

class User extends Person {
	constructor(firstname, lastname, role){
		super(firstname, lastname);
		this.role = role;
	}

	get isAdmin(){
		return this.role === "admin"
	}
}

const bill = new User("Bill", "Gates", "admin")
							</code></pre>
							<div class="left">
								<div class="arrow left fragment" style="top: 34px; right: 80px">explicit <code>constructor</code> property</div>
								<div class="arrow left fragment" style="top: 175px; right: 150px;">simplifies the assignation of the prototype</div>
								<div class="arrow left fragment" style="top: 180px; right: 120px">simplifies the call to the prototype constructor</div>

							</div>
						</div>
					</section>

					<section>
						<h3>super</h3>
						<pre><code class="javascript hljs js" data-trim>
							super(...args); // call the prototype constructor

							super.method(); // call a method of the prototype
						</code></pre>
						<p>It is usable without the class operator:</p>
						<pre style="font-size: 60%"><code class="javascript hljs js" data-trim>
							const user = {
								name: "Anonymous",
								getName(){ return this.name }
							}

							const joe = {
								name: "Joe",
								getName(){
									return `joe name: ${this.name} ; user name: ${super.name} : user getName: ${super.getName()}`
								}
							}

							Object.setPrototypeOf(joe, user)

							joe.getName()
							▸ joe name: Joe ; user name: Anonymous ; user getName: Joe
						</code></pre>
					</section>

					<section>
						<h3>static</h3>
						<p>Defines a static property: a property of the constructor itself, not the prototype</p>
						<pre><code class="javascript hljs js" data-trim>
class C {
	method(){ console.log("method") }

	static methodStatic(){ console.log("static method") }
}

(new C()).method() // method in C.prototype
C.methodStatic() // methodStatic in C
						</code></pre>
						<p>This is basically the same thing than directly assigning the property to the constructor, so not the most useful syntaxic sugar, but it was added for its familiarity for Java developers.</p>
						<pre><code class="javascript hljs js" data-trim>
							C.equivalentStatic = function(){ ... }
						</code></pre>
					</section>

					<section>
						<h3>Constructors flaws, with operator <code>class</code></h3>
						<ul>
							<li class="fragment">The prototype constructors are not automatically invoked, you have to do it manually.
								<div><img alt="fixed" src="assets/img/patch.png" style="height: 28px; display: inline-block; vertical-align: middle;" /> still the case but simplified with <code>super()</code></div>
							</li>
							<li class="fragment">The prototype constructor may not have the same signature, which breaks the <a target="_blank" href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">principle of substitution</a>.
								<div><img alt="Not fixed" src="assets/img/smiley-sad.png" style="height: 28px; display: inline-block; vertical-align: middle;" /> still the case</div></li>
							<li class="fragment">A <code>constructor</code> property is assigned to constructed objects, which can break existing code if you use this property for other effects, for example: <code>car.constructor = "Toyota"</code>
								<div><img alt="fixed" src="assets/img/patch.png" style="height: 28px; display: inline-block; vertical-align: middle;" /> still the case but the assignation is explicit to prevent conflicts</div></li>
							<li class="fragment"><code>this</code> keyword does not work the same depending on whether the function is called with operator <code>new</code> or not
								<div><img alt="fixed" src="assets/img/patch.png" style="height: 28px; display: inline-block; vertical-align: middle;" /> an exception is raised if constructor is not called with <code>new</code></div></li>
							<li class="fragment">It is not possible to declare several constructors
								<div><img alt="Not fixed" src="assets/img/smiley-sad.png" style="height: 28px; display: inline-block; vertical-align: middle;" /> still the case</div></li>
							<li class="fragment">They are confusing for beginners with prototypes
								<div><img alt="Not fixed" src="assets/img/smiley-sad.png" style="height: 28px; display: inline-block; vertical-align: middle;" /> adds even more confusion with class-based OOP</div>
							</li>
						</ul>
					</section>

					<section>
						<h3>Alternative to constructors</h3>
						<p >You don't need constructors to make prototype-based OOP. You can rather use:</p>
						<ul class="left">
							<li>Factory functions
								<pre><code class="javascript hljs js" data-trim>
function createUser({ first, name }){
	const user = Object.create(userProto)
	user.first = first
	user.name = name
	return user
}</code></pre></li>
							<li><code>Object.create</code> and <code>Object.assign</code>
								<pre><code class="javascript hljs js" data-trim>
const john = Object.assign(Object.create(userProto), {
	first: "John",
	name: "Smith"
})</code></pre>
							</li>
						</ul>
						<p>It fixes all the flaws previously stated, and you don't need these anymore:</p>
						<p><code>new, instanceof, class, super, static</code></p>
					</section>

					<section>
						<h3>class vs Object.create: an example</h3>
						<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1em;">
							<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
class Foo {
	constructor(who){
		this.me = who
	}
	identify(){
		return `I am ${this.me}`
	}
}

class Bar extends Foo {
	speak(){
		return `Hello, ${this.identify()}`
	}
}

let b1 = new Bar("b1")
let b2 = new Bar("b2")

b1.speak();
b2.speak();
								</code></pre>
								<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
const Foo = {
	init(who){
		this.me = who
		return this
	},
	identify(){
		return `I am ${this.me}`
	}
}

const Bar = Object.create(Foo)
Bar.speak = function(){
	return `Hello, ${this.identify()}`
}

let b1 = Object.create(Bar).init("b1");
let b2 = Object.create(Bar).init("b2");

b1.speak();
b2.speak();
								</code></pre>
						</div>
					</section>

					<section>
						<h3>Delegation pattern, in short</h3>
						<ul>
							<li>Lighter and simpler model</li>
							<li>Replace the notion of constructors by factory functions or initialization methods </li>
							<li>No longer needs <code>new</code> and <code>instanceof</code> operators</li>
							<li>Requires to get out of the mental model of class hierarchies</li>
						</ul>
						<div class="note left">
							<u>Recommended:</u>
							<p>Use <code>Object.create</code> and <code>class extends</code> with moderation</p>
							<p>Limit the size of your prototype chains as much as possible</p>
							<p>Delegation is a powerful and flexible pattern, but other approachs such as <b>object composition</b> are underused.</p>
						</div>
					</section>

					<section>
						<h3>Object composition (a.k.a. Mixins)</h3>
						<p>Another pattern in JavaScript OOP consists of creating objects by composition.</p>
						<p>This pattern is super simple because JS objects support dynamic assignation of new properties:</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							const mixin = { ...objA, ...objB }
							// or
							const mixin = Object.assign({}, objA, objB)
						</code></pre>
						<p>The composition is ordered, applying arguments from left to right, so that in case of conflicts on one property name, the last one gets priority:</p>
						<pre style="font-size: 70%"><code class="javascript hljs js" data-trim>
							let o = { ...{ x: 1 }, ...{ x: 2 }, ...{ x: 3 } }
							o
							▸ { x: 3 }
						</code></pre>
					</section>

					<section>
						<h3>Composition or delegation ?</h3>
						<img src="assets/img/design-patterns-book.png"
						alt="Cover of book: Design Patterns - Elements of Reusable Object-oriented software" style="float: right; height: 200px" />
						<blockquote style="margin: 100px 0 100px auto">
							Favor object composition over class inheritance
							<br>(Gang of Four 1995:20)
						</blockquote>
						<p>In reality, there is no pattern always better than another:<br/>they match with different ways of thinking.</p>
						<p>The flaws of each pattern became clear when you start to excessively use it anywhere.</p>
						<p>Take the time to think about your model,
							do not code by habit.</p>
					</section>

					<section class="left">
						<div class="ref">Exercise 17</div>
						<h3>Object patterns: exercise</h3>
						<p>Let's practice on a project example: a web components library</p>
						<p>Objects identified in the model:</p>
						<ul>
							<li><code>Component</code></li>
							<li><code>Clickable</code></li>
							<li><code>Focusable</code></li>
							<li><code>Editable</code></li>
							<li><code>Button</code></li>
							<li><code>Input</code></li>
							<li><code>TextInput</code></li>
						</ul>
						<p>
							<u>Objectives</u>
							<ol>
								<li>think about the model, find the right relations between objects:
									<br><b>Delegation ? Composition ? Encapsulation ?</b>
								</li>
								<li>implement the relations between objects</li>
								<li>test the example using components Button and TextInput</li>
							</ol>
						</p>
					</section>


				</section>

		
			</div>
		</div>
	</body>

	<script src="./assets/plugin/notes/notes.js"></script>
	<script src="./assets/plugin/markdown/markdown.js"></script>
	<script src="./assets/plugin/highlight/highlight.js"></script>
	<script src="./assets/plugin/internation/internation.js"></script>
	<script type="module" src="./main.js"></script>
</html>